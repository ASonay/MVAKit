import numpy as np
import pandas as pd

def TrainKerasModel(path,model,opt,x,y,w,custom_callbacks=None):
    from tensorflow.keras.optimizers import SGD,Adam,RMSprop,schedules
    from tensorflow.keras.models import Sequential

    getopt = opt.split(',')
    optlist={}
    for o in getopt:
        osplit=o.split(';')
        if len(osplit) == 2:
            optlist[osplit[0].upper()]=osplit[1]
        else:
            print ('Your options has to be like following,')
            print ('opt1;val1,...,optn;valn')
            exit()
    
    lrate=float(optlist['LRATE'])
    momentum=float(optlist['MOMENTUM'])
    nepoch=int(optlist['EPOCH'])
    batch=int(optlist['BATCH'])
    optimizer=optlist['OPTIMIZER']
    loss=optlist['LOSS']

    lrate_dec=0
    lrate_step=0
    if 'LRATE_DEC' in optlist: lrate_dec=float(optlist['LRATE_DEC'])
    if 'LRATE_STEP' in optlist: lrate_step=int(optlist['LRATE_STEP'])

    #Metrics
    mets=[]
    #if loss == 'Exp': mets.append(ExponentialLoss_Metric)

    #Callbacks
    cbacks=[]
    if custom_callbacks != None: cbacks.append(custom_callbacks) 

    if loss == 'Exp':
        loss = ExponentialLoss()

    if lrate_dec>0 and lrate_step>0:
        lrate = schedules.ExponentialDecay(initial_learning_rate=float(optlist['LRATE']),
                                 decay_steps=lrate_step,
                                 decay_rate=lrate_dec)
    print("Learning rate sceduled with initial rate "+str(float(optlist['LRATE']))+" by "+str(lrate_dec)+" decay and for each "+str(lrate_step)+" step.")

    optim=None
    if optimizer.upper() == 'SGD':
        optim=SGD(learning_rate=lrate, momentum=momentum)
    elif optimizer.upper() == 'ADAM':
        optim=Adam(learning_rate=lrate)
    elif optimizer.upper() == 'RMSPROP':
        optim=RMSprop(learning_rate=lrate, momentum=momentum)
    else:
        print ('Available optimizers: SGD,ADAM,RMSPROP')
        print ('You choose none, SGD will be run..')
        optim=SGD(learning_rate=lrate, momentum=momentum)
    
    model.compile(loss=loss, optimizer=optim, metrics=mets)
    print (model.summary())
    model.fit(np.array(x).astype(np.float32), np.array(y).astype(np.float32), sample_weight = np.array(w).astype(np.float32), epochs=nepoch, batch_size=batch, callbacks=cbacks)

    
def CompileKerasModel(model,opt):
    from tensorflow.keras.optimizers import SGD,Adam,RMSprop,schedules
    from tensorflow.keras.models import Sequential
    getopt = opt.split(',')
    optlist={}
    for o in getopt:
        osplit=o.split(';')
        if len(osplit) == 2:
            optlist[osplit[0].upper()]=osplit[1]
        else:
            print ('Your options has to be like following,')
            print ('opt1;val1,...,optn;valn')
            exit()
    
    lrate=float(optlist['LRATE'])
    momentum=float(optlist['MOMENTUM'])
    nepoch=int(optlist['EPOCH'])
    batch=int(optlist['BATCH'])
    optimizer=optlist['OPTIMIZER']
    loss=optlist['LOSS']

    optim=None
    if optimizer.upper() == 'SGD':
        optim=SGD(lr=lrate, momentum=momentum)
    elif optimizer.upper() == 'ADAM':
        optim=Adam(lr=lrate)
    elif optimizer.upper() == 'RMSPROP':
        optim=RMSprop(lr=lrate, momentum=momentum)
    else:
        print ('Available optimizers: SGD,ADAM,RMSPROP')
        print ('You choose none, SGD will be run..')
        optim=SGD(lr=lrate, momentum=momentum)
        
    model.compile(loss=loss, optimizer=optim, metrics=['accuracy'])
    print (model.summary())

def SaveKerasModel(model,fil):
    from tensorflow.keras.optimizers import SGD,Adam,RMSprop,schedules
    from tensorflow.keras.models import Sequential
    with open(fil, 'w') as fout:
        for ind,layer in enumerate(model.layers):
            fout.write('Start for layer ' + str(ind) + '\n')
            W = layer.get_weights()[0]
            for i in range(W.shape[0]):
                fout.write('\n')
                for j in range(W.shape[1]):
                    fout.write(str(W[i,j]) + ' ')
            fout.write('\n')
            fout.write('Bias\n')
            bias = layer.get_weights()[1]
            for i in range(bias.shape[0]):
                fout.write(str(bias[i]) + ' ')
            fout.write('\n\n')
            fout.write('End of layer ' + str(ind) + '\n')
            fout.write('\n\n')
